package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// We want to test against a specific version rather than the latest. When the
// package is upgraded to a new version, change these to generate new tests.
const (
	unicodeVersion           = "16.0.0"
	derivedCorePropertiesURL = `https://www.unicode.org/Public/%s/ucd/DerivedCoreProperties.txt`
)

var propertyPattern = regexp.MustCompile(`^([0-9A-F]{4,6})(?:\.\.([0-9A-F]{4,6}))?\s*;\s*InCB\s*;\s*([A-Za-z0-9]+)\s*#\s(.+)$`)

func main() {
	log.SetPrefix("gen_incb: ")
	log.SetFlags(0)

	src, err := parse()
	if err != nil {
		log.Fatal(err)
	}
	const outputFilename = "indic_conjunct_break.go"

	// Format the Go code.
	formatted, err := format.Source([]byte(src))
	if err != nil {
		log.Fatal("gofmt:", err)
	}

	// Save it to the (local) target file.
	log.Print("Writing to ", outputFilename)
	if err := os.WriteFile(outputFilename, formatted, 0644); err != nil {
		log.Fatal(err)
	}
}

func parse() (string, error) {
	propertyURL := fmt.Sprintf(derivedCorePropertiesURL, unicodeVersion)
	log.Printf("Parsing %s", propertyURL)
	res, err := http.Get(propertyURL)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	// Temporary buffer to hold properties.
	var properties [][4]string

	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		line := scanner.Text()

		// Skip comments and empty lines.
		if strings.HasPrefix(line, "#") || line == "" {
			continue
		}

		from, to, property, comment, err := parseProperty(line)
		if err != nil {
			continue
		}
		properties = append(properties, [4]string{from, to, property, comment})
	}
	if err := scanner.Err(); err != nil {
		return "", err
	}
	// Sort properties.
	sort.Slice(properties, func(i, j int) bool {
		left, _ := strconv.ParseUint(properties[i][0], 16, 64)
		right, _ := strconv.ParseUint(properties[j][0], 16, 64)
		return left < right
	})
	properties = eytzinger(properties)

	// Header
	var buf bytes.Buffer
	buf.WriteString(`// Code generated by internal/cmd/gen_incb; DO NOT EDIT.
	
package uniseg

// incb are token from
// ` + propertyURL + `
// See https://www.unicode.org/license.html for the Unicode license agreement.
var incb = dictionary[incbProperty]{
`)

	for _, prop := range properties {
		fmt.Fprintf(
			&buf,
			"{runeRange{%s,%s}, %s}, // %s\n",
			formatRune(prop[0]),
			formatRune(prop[1]),
			translateProperty(prop[2]),
			prop[3],
		)
	}

	// Tail.
	buf.WriteString("}")

	return buf.String(), nil
}

func formatRune(s string) string {
	if s == "" {
		return "0"
	}
	return "0x" + s
}

func translateProperty(property string) string {
	if property == "" {
		return "0"
	}
	return "incb" + strings.ReplaceAll(property, "_", "")
}

// parseProperty parses a line of the Unicode properties text file containing a
// property for a code point range and returns it along with its comment.
func parseProperty(line string) (from, to, property, comment string, err error) {
	fields := propertyPattern.FindStringSubmatch(line)
	if fields == nil {
		err = errors.New("no property found")
		return
	}
	from = fields[1]
	to = fields[2]
	if to == "" {
		to = from
	}
	property = fields[3]
	comment = fields[4]
	return
}

func eytzinger[S ~[]E, E any](a S) S {
	b := make(S, len(a))
	ctx := &eytzingerContext[S, E]{a: a, b: b}
	ctx.eytzinger(0, 0)
	return b
}

type eytzingerContext[S ~[]E, E any] struct {
	a S // input slice
	b S // output slice
}

func (ctx *eytzingerContext[S, E]) eytzinger(i, k int) int {
	if k < len(ctx.a) {
		i = ctx.eytzinger(i, 2*k+1)
		ctx.b[k] = ctx.a[i]
		i++
		i = ctx.eytzinger(i, 2*k+2)
	}
	return i
}
